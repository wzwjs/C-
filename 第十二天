//不能一下子，跑的太猛，容易跑不下去,适当放松


//第十二天，运算符重载


//运算符重载
	//对已经有的运算符重新进行定义，赋予其另一种新的功能，以适应不同数据类型

          //加法运算符重载
          //左移运算符重载
          //递增运算符重载
          //赋值运算符重载
          //关系运算符重载
          //函数调用运算符重载



//加法运算符重载
 
//语法格式 oprator+
        //Person operator+(const Person& p)
        //数据类型（类名） opertor+(const Person &p)  这里写引用的目的的为了防止形参改变实参

//类型
    //成员函数重载
    //全局函数重载
    //运算符重载，也可以发生函数重载

//总结1，对于内置的数据类型的表达式的运算符是不可能改变的
//总结2，不要滥用运算符重载

//感想：
    //其实对于c++编译器里，还有很多的功能，逻辑，接口没有封装好，给我们调用
    //就以基本的运算符，只能匹配编译器里面已经有的数据类型
    //面对类实例化属性后的加减乘除，就无法直接操作，这样，我们就需要对运算符的功能进行重载
    //让编译器看到我们的类实例化的加减乘除，能认识并理解




//左移运算符
//左移运算符配合友元可以实现自定义数据类型
//作用：可以输出自定义数据类型




//递增运算符重载
//借用编译器封装好的oprator函数去自己实现变量++；++变量的操作



 //赋值运算符重载

//赋值运算符重载
	//C++编译器至少给一个类添加4给函数
	//1,默认构造函数（无参，函数体为空)
	//2，默认析构函数(无参，函数体为空)
	//3,默认拷贝构造函数，对属性的值进行拷贝
	//4,赋值运算符operator=,对属性进行值拷贝

//如果类中有属性指向堆区，做赋值操作时会出现深拷贝和浅拷贝问题
//编译器提供的代码是浅拷贝
//提供深拷贝，解决浅拷贝的问题




//关系运算符重载
	//重载关系运算符，可以让两个自定义的类型对象进行比对操作



//函数调用运算符重载
	//函数调用运算符()也可以重载
	//由于重载后使用非常像函数的调用，因此称为仿函数
	//防函数没有固定的写法，非常灵活


//总结，运算符重载的意思就是解决编译器没有提供的，而实际开发中需要的功能，重载一下运算符的功能，使其能满足实际生产的需求
